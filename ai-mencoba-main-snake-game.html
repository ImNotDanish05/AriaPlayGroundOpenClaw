<!doctype html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI mencoba main Snake Game</title>
  <style>
    :root {
      --bg: #0f1226;
      --panel: #171a35;
      --text: #e9ecff;
      --muted: #aeb6e6;
      --apple: #ff5f7a;
      --snake: #7bffb2;
      --head: #35d0ff;
      --ok: #7bffb2;
      --warn: #ffd166;
      --bad: #ff6b6b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background:
        radial-gradient(900px 500px at 10% -10%, #2a2f66 0%, transparent 45%),
        radial-gradient(700px 400px at 120% 0%, #124d6c 0%, transparent 45%),
        var(--bg);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      padding: 20px;
    }
    .card {
      width: min(620px, 100%);
      background: rgba(23, 26, 53, 0.9);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      overflow: hidden;
    }
    .top {
      padding: 14px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      flex-wrap: wrap;
    }
    .title { font-weight: 800; letter-spacing: .3px; }
    .meta { color: var(--muted); font-size: 14px; }
    .board-wrap { display: grid; place-items: center; padding: 14px; }
    canvas {
      background: #0b0f1f;
      border: 1px solid rgba(255,255,255,0.13);
      border-radius: 10px;
      width: 100%;
      max-width: 560px;
      aspect-ratio: 1/1;
      image-rendering: pixelated;
    }
    .bar {
      display: flex;
      gap: 12px;
      padding: 0 14px 14px;
      color: var(--muted);
      font-size: 14px;
      flex-wrap: wrap;
    }
    .pill {
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 999px;
      padding: 6px 10px;
      background: rgba(255,255,255,.03);
    }
    .ok { color: var(--ok); font-weight: 700; }
    .warn { color: var(--warn); font-weight: 700; }
    .bad { color: var(--bad); font-weight: 700; }
  </style>
</head>
<body>
  <main class="card">
    <section class="top">
      <div class="title">ðŸ¤– AI mencoba main Snake Game</div>
      <div class="meta">Autoplay ON (user tidak bisa kontrol)</div>
    </section>

    <section class="board-wrap">
      <canvas id="game" width="560" height="560"></canvas>
    </section>

    <section class="bar">
      <div class="pill">Score: <span id="score">0</span></div>
      <div class="pill">Panjang: <span id="len">1</span></div>
      <div class="pill">Mode: <span id="mode">Adaptive</span></div>
      <div class="pill">Status: <span id="status">Running...</span></div>
      <div class="pill">Strategi: BFS + ruang aman + sedikit improvisasi</div>
    </section>
  </main>

  <script>
    const N = 20;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const cell = canvas.width / N;

    const scoreEl = document.getElementById('score');
    const lenEl = document.getElementById('len');
    const statusEl = document.getElementById('status');
    const modeEl = document.getElementById('mode');

    const SPEED_MS = 90;
    const DIRS = [
      {x:1,y:0,name:'R'},
      {x:-1,y:0,name:'L'},
      {x:0,y:1,name:'D'},
      {x:0,y:-1,name:'U'},
    ];

    let snake = [{x:10,y:10}];
    let apple = spawnApple(snake);
    let score = 0;
    let gameOver = false;

    function key(p){ return `${p.x},${p.y}`; }
    function inBounds(p){ return p.x >= 0 && p.y >= 0 && p.x < N && p.y < N; }
    function equal(a,b){ return a.x===b.x && a.y===b.y; }
    function manhattan(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }

    function spawnApple(currentSnake){
      const occ = new Set(currentSnake.map(key));
      const free = [];
      for(let y=0;y<N;y++) for(let x=0;x<N;x++){
        const p = {x,y};
        if(!occ.has(key(p))) free.push(p);
      }
      if (!free.length) return null;
      return free[Math.floor(Math.random() * free.length)];
    }

    function neighbors(pos, blockedSet){
      const out=[];
      for(const d of DIRS){
        const p = {x:pos.x+d.x, y:pos.y+d.y};
        if(inBounds(p) && !blockedSet.has(key(p))) out.push(p);
      }
      return out;
    }

    function bfsPath(start, target, blockedSet){
      const q=[start];
      const seen=new Set([key(start)]);
      const prev=new Map();

      while(q.length){
        const cur=q.shift();
        if(equal(cur,target)) break;
        for(const nxt of neighbors(cur, blockedSet)){
          const k=key(nxt);
          if(seen.has(k)) continue;
          seen.add(k);
          prev.set(k, cur);
          q.push(nxt);
        }
      }

      if(!seen.has(key(target))) return null;
      const path=[target];
      let cur=target;
      while(!equal(cur,start)){
        cur=prev.get(key(cur));
        path.push(cur);
      }
      path.reverse();
      return path;
    }

    function reachableArea(start, blockedSet){
      const q=[start];
      const seen=new Set([key(start)]);
      while(q.length){
        const cur=q.shift();
        for(const nxt of neighbors(cur, blockedSet)){
          const k=key(nxt);
          if(seen.has(k)) continue;
          seen.add(k);
          q.push(nxt);
        }
      }
      return seen.size;
    }

    function simulateMove(nextHead){
      const willEat = equal(nextHead, apple);
      const newSnake = [nextHead, ...snake];
      if(!willEat) newSnake.pop();
      return { newSnake, willEat };
    }

    function chooseMove(){
      const head = snake[0];
      const tail = snake[snake.length-1];
      const blocked = new Set(snake.slice(0, -1).map(key)); // tail dianggap bisa bergerak

      // Urutan preferensi dibuat random biar gaya gerak nggak kaku
      const shuffled = [...DIRS].sort(() => Math.random() - 0.5);
      const candidates = [];

      for (const d of shuffled){
        const next = {x:head.x + d.x, y:head.y + d.y};
        if(!inBounds(next)) continue;
        if(blocked.has(key(next))) continue;

        const { newSnake, willEat } = simulateMove(next);
        const blockedAfter = new Set(newSnake.slice(0,-1).map(key));
        const tailAfter = newSnake[newSnake.length-1];

        // Safety heuristik: tetap ada path ke tail sesudah move
        const pathToTail = bfsPath(newSnake[0], tailAfter, blockedAfter);
        const safe = !!pathToTail;

        // Luas ruang yang bisa dijangkau dari kepala
        const area = reachableArea(newSnake[0], blockedAfter);

        // Bisa dapat apel cepat?
        const pathToApple = apple ? bfsPath(newSnake[0], apple, blockedAfter) : null;
        const distApple = pathToApple ? pathToApple.length : 999;

        candidates.push({
          next, safe, area, distApple,
          greed: apple ? -manhattan(next, apple) : 0,
          willEat
        });
      }

      if(!candidates.length) return null;

      // Mode adaptif
      // - awal game: lebih agresif cari apel
      // - makin panjang: lebih aman
      const fill = snake.length / (N*N);
      let mode = 'Aggressive';
      if(fill > 0.45) mode = 'Balanced';
      if(fill > 0.7) mode = 'Safe';
      modeEl.textContent = mode;

      // Sedikit "human-like noise" supaya tidak terlalu robotik
      const chaos = fill < 0.35 ? 0.12 : 0.05; // 12% di awal, turun jadi 5%

      // Ranking kandidat
      candidates.sort((a,b)=>{
        // safety dulu
        if(a.safe !== b.safe) return (b.safe?1:0) - (a.safe?1:0);

        if(mode === 'Aggressive'){
          if(a.distApple !== b.distApple) return a.distApple - b.distApple;
          if(a.area !== b.area) return b.area - a.area;
          return b.greed - a.greed;
        }
        if(mode === 'Balanced'){
          if(a.area !== b.area) return b.area - a.area;
          if(a.distApple !== b.distApple) return a.distApple - b.distApple;
          return b.greed - a.greed;
        }
        // Safe
        if(a.area !== b.area) return b.area - a.area;
        if(a.safe !== b.safe) return (b.safe?1:0) - (a.safe?1:0);
        return a.distApple - b.distApple;
      });

      let picked = candidates[0];
      if (Math.random() < chaos && candidates.length > 1) {
        // ambil kandidat lain yg masih cukup bagus biar variasi gerak terasa
        picked = candidates[Math.min(1 + Math.floor(Math.random()*2), candidates.length - 1)];
      }

      return picked.next;
    }

    function step(){
      if(gameOver) return;

      const next = chooseMove();
      if(!next){
        gameOver = true;
        statusEl.textContent = 'Kalah ðŸ˜µ (AI kejebak)';
        statusEl.className = 'bad';
        return;
      }

      snake.unshift(next);
      if(equal(next, apple)){
        score++;
        apple = spawnApple(snake);
        if(!apple){
          gameOver = true;
          statusEl.textContent = 'MENANG! Board penuh ðŸŽ‰';
          statusEl.className = 'ok';
        }
      } else {
        snake.pop();
      }

      scoreEl.textContent = score;
      lenEl.textContent = snake.length;
    }

    function roundRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    function drawGrid() {
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= N; i++) {
        ctx.beginPath(); ctx.moveTo(i * cell, 0); ctx.lineTo(i * cell, canvas.height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, i * cell); ctx.lineTo(canvas.width, i * cell); ctx.stroke();
      }
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const grad = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
      grad.addColorStop(0, '#0b0f1f');
      grad.addColorStop(1, '#111737');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      drawGrid();

      if(apple){
        ctx.fillStyle = '#ff5f7a';
        roundRect(apple.x * cell + 4, apple.y * cell + 4, cell - 8, cell - 8, 8);
        ctx.fill();
      }

      for(let i = snake.length - 1; i >= 0; i--){
        const s = snake[i];
        ctx.fillStyle = i === 0 ? '#35d0ff' : '#7bffb2';
        roundRect(s.x * cell + 3, s.y * cell + 3, cell - 6, cell - 6, 7);
        ctx.fill();
      }
    }

    // Tetap non-interaktif
    window.addEventListener('keydown', (e) => {
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    }, { passive: false });

    const loop = setInterval(() => {
      step();
      draw();
      if(gameOver) clearInterval(loop);
    }, SPEED_MS);
    draw();
  </script>
</body>
</html>
