<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chrome Dino AI (Autoplay)</title>
  <style>
    :root { --w: 960; --h: 260; }
    body { margin: 0; background: #f6f7fb; font-family: Inter, system-ui, Arial, sans-serif; display: grid; place-items: center; min-height: 100vh; }
    .wrap { width: min(96vw, calc(var(--w) * 1px)); }
    .hud { display:flex; justify-content:space-between; margin-bottom:8px; color:#333; font-weight:600; }
    canvas { width: 100%; height: auto; border: 2px solid #ddd; background: #fff; image-rendering: pixelated; }
    .tips { margin-top: 8px; color:#666; font-size: 13px; }
    kbd { background:#eee; border:1px solid #d0d0d0; border-bottom-width:2px; border-radius:4px; padding:1px 6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud"><span>ðŸ¦– Dino AI Autoplay</span><span id="score">Score: 0</span></div>
    <canvas id="game" width="960" height="260"></canvas>
    <div class="tips">Manual: <kbd>Space</kbd> jump, <kbd>ArrowDown</kbd> duck. Toggle AI: <kbd>A</kbd>. Restart: <kbd>R</kbd>.</div>
  </div>

  <script>
    const c = document.getElementById('game');
    const ctx = c.getContext('2d');
    const scoreEl = document.getElementById('score');

    const GROUND_Y = 210;
    const gravity = 0.9;
    const jumpVel = -15.5;

    const state = {
      running: true,
      ai: true,
      t: 0,
      score: 0,
      speed: 7,
      spawnCooldown: 0,
      obstacles: [],
      clouds: Array.from({length: 5}, (_,i)=>({x: i*220+120, y: 20 + Math.random()*55, w: 46+Math.random()*24, s: 0.3+Math.random()*0.4})),
      dino: {
        x: 90,
        y: GROUND_Y,
        w: 44,
        h: 48,
        vy: 0,
        ducking: false,
        onGround: true,
        jumpCount: 0,
      },
      downPressed: false,
    };

    function reset() {
      state.running = true;
      state.t = 0;
      state.score = 0;
      state.speed = 7;
      state.spawnCooldown = 30;
      state.obstacles.length = 0;
      Object.assign(state.dino, { y: GROUND_Y, vy: 0, ducking:false, onGround:true, jumpCount:0 });
    }

    function spawnObstacle() {
      const r = Math.random();
      // 0..0.6 cactus, 0.6..1 ptero
      if (r < 0.62) {
        const variant = Math.random();
        const w = variant < 0.4 ? 24 : (variant < 0.8 ? 34 : 46);
        const h = variant < 0.4 ? 40 : (variant < 0.8 ? 52 : 56);
        state.obstacles.push({ type: 'cactus', x: c.width + 20, y: GROUND_Y, w, h });
      } else {
        const lvl = Math.random();
        const flight = lvl < 0.33 ? GROUND_Y - 20 : (lvl < 0.66 ? GROUND_Y - 48 : GROUND_Y - 78);
        state.obstacles.push({ type: 'ptero', x: c.width + 20, y: flight, w: 46, h: 30, flap: 0 });
      }
      const base = Math.max(36, 92 - state.speed * 4.2);
      state.spawnCooldown = base + Math.random() * (base * 0.9);
    }

    function jump() {
      const d = state.dino;
      if (d.onGround) {
        d.vy = jumpVel;
        d.onGround = false;
        d.jumpCount++;
      }
    }

    function setDuck(v) {
      state.dino.ducking = v && !state.dino.onGround ? false : v;
    }

    function updateDino() {
      const d = state.dino;
      d.vy += gravity;
      d.y += d.vy;
      if (d.y >= GROUND_Y) {
        d.y = GROUND_Y;
        d.vy = 0;
        d.onGround = true;
      } else d.onGround = false;
    }

    function dinoBox() {
      const d = state.dino;
      const h = d.ducking && d.onGround ? 30 : d.h;
      const y = d.y - h;
      const w = d.ducking && d.onGround ? 56 : d.w;
      return { x: d.x + 4, y: y + 3, w: w - 8, h: h - 6 };
    }

    function collide(a,b) {
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function classifyPtero(ob) {
      const top = ob.y - ob.h;
      // Tuned to this game's spawn heights:
      // low ~ top 160, mid ~132, high ~102 (GROUND=210, bird h=30)
      if (top > GROUND_Y - 62) return 'low';
      if (top > GROUND_Y - 92) return 'mid';
      return 'high';
    }

    function getNearestObstacle() {
      const d = state.dino;
      return state.obstacles
        .filter(o => o.x + o.w > d.x - 8)
        .sort((a,b)=>a.x-b.x)[0] || null;
    }

    function computeJumpTrigger(ob) {
      // Heuristic from common dino bots: threshold grows with speed and obstacle width.
      // Tuned to avoid "jump exactly on top" by biasing earlier jump.
      const v = state.speed;
      if (ob.type === 'cactus') {
        return 72 + v * 6.2 + ob.w * 0.65;
      }
      const band = classifyPtero(ob);
      if (band === 'low') return 78 + v * 5.8;
      return Infinity; // mid/high ptero should duck, not jump
    }

    function aiControl() {
      if (!state.ai || !state.running) return;
      const d = state.dino;

      if (state.aiJumpLock == null) state.aiJumpLock = 0;
      if (state.aiJumpLock > 0) state.aiJumpLock--;
      if (state.aiPlan == null) state.aiPlan = null;

      const nearest = getNearestObstacle();
      if (!nearest) {
        setDuck(false);
        state.aiPlan = null;
        return;
      }

      const dx = nearest.x - d.x;
      if (dx > 340) {
        setDuck(false);
        state.aiPlan = null;
        return;
      }

      // REBUILT duck logic (reference style: distance + target lock + release-after-pass)
      if (state.duckTarget == null) state.duckTarget = null;
      if (state.duckHoldUntil == null) state.duckHoldUntil = 0;

      // Continue duck if we already locked onto a bird target.
      if (state.duckTarget) {
        const b = state.duckTarget;
        const dinoLeft = d.x + 4;
        const birdRight = b.x + b.w - 3;
        const passed = birdRight < dinoLeft - 10;

        if (passed) {
          // tiny tail hold so no instant stand-up collision
          if (state.duckHoldUntil === 0) state.duckHoldUntil = state.t + Math.floor(8 + state.speed * 0.35);
        }

        const keep = d.onGround && (!passed || state.t <= state.duckHoldUntil) && state.obstacles.includes(b);
        setDuck(keep);
        if (!keep) {
          state.duckTarget = null;
          state.duckHoldUntil = 0;
        }
      } else {
        // Acquire new duck target only for ptero mid/high and when truly close.
        if (nearest.type === 'ptero' && d.onGround) {
          const band = classifyPtero(nearest);
          if (band === 'mid' || band === 'high') {
            const dinoLeft = d.x + 4;
            const dinoRight = dinoLeft + 36;
            const birdLeft = nearest.x + 3;
            const birdRight = nearest.x + nearest.w - 3;
            const frontGap = birdLeft - dinoRight;

            // Start duck late enough (avoid early crouch), but safe at higher speed.
            const startGap = 26 + state.speed * 1.15;
            const shouldAcquire = frontGap <= startGap && birdRight > dinoLeft;

            if (shouldAcquire) {
              state.duckTarget = nearest;
              state.duckHoldUntil = 0;
              setDuck(true);
            } else {
              setDuck(false);
            }
          } else {
            // low bird handled by jump logic
            setDuck(false);
          }
        } else {
          setDuck(false);
        }
      }

      // Build a stable jump plan (prevents jitter / repeated re-planning)
      const jumpTrigger = computeJumpTrigger(nearest);
      const jumpable = Number.isFinite(jumpTrigger) && d.onGround && state.aiJumpLock === 0;

      if (jumpable && !state.aiPlan) {
        const initialDx = Math.max(1, dx);
        state.aiPlan = {
          obstacleRef: nearest,
          initialDx,
          triggerDx: Math.min(jumpTrigger, initialDx * 0.58), // ~50-60% hold from first detection
          expiryTick: state.t + 90
        };
      }

      if (!state.aiPlan) return;

      const plan = state.aiPlan;
      const stale = state.t > plan.expiryTick || !state.obstacles.includes(plan.obstacleRef);
      if (stale) {
        state.aiPlan = null;
        return;
      }

      const curDx = plan.obstacleRef.x - d.x;
      // safety: force jump if already too close to jumpable obstacle
      const urgent = curDx < 34 + state.speed * 1.1;

      if (d.onGround && state.aiJumpLock === 0 && (curDx <= plan.triggerDx || urgent)) {
        jump();
        state.aiJumpLock = Math.max(9, Math.floor(17 - state.speed * 0.28));
        state.aiPlan = null;
      }
    }

    function update() {
      if (!state.running) return;

      state.t++;
      state.score += 0.12;
      state.speed = Math.min(40, 7 + state.t / 900);

      state.spawnCooldown -= 1;
      if (state.spawnCooldown <= 0) spawnObstacle();

      for (const cl of state.clouds) {
        cl.x -= cl.s + state.speed * 0.08;
        if (cl.x < -100) {
          cl.x = c.width + Math.random()*120;
          cl.y = 18 + Math.random()*60;
        }
      }

      for (const ob of state.obstacles) {
        ob.x -= state.speed;
        if (ob.type === 'ptero') ob.flap += 0.22;
      }
      state.obstacles = state.obstacles.filter(o => o.x + o.w > -40);

      aiControl();
      updateDino();

      const db = dinoBox();
      for (const o of state.obstacles) {
        const hit = { x: o.x + 3, y: o.y - o.h + 2, w: o.w - 6, h: o.h - 4 };
        if (collide(db, hit)) {
          state.running = false;
          setDuck(false);
          break;
        }
      }

      scoreEl.textContent = `Score: ${Math.floor(state.score)} | Speed: ${state.speed.toFixed(2)}${state.ai ? ' (AI)' : ''}${state.running ? '' : '  â€” GAME OVER'}`;
    }

    function drawDino(isNight = false) {
      const d = state.dino;
      const duck = d.ducking && d.onGround;
      const h = duck ? 30 : d.h;
      const w = duck ? 56 : d.w;
      const y = d.y - h;

      // body
      ctx.fillStyle = isNight ? '#e8ecf5' : '#2e2e2e';
      ctx.fillRect(d.x + 8, y + 8, w - 10, h - 10);

      // head
      if (!duck) {
        ctx.fillRect(d.x + w - 16, y - 4, 14, 14);
        ctx.fillStyle = isNight ? '#1f2430' : '#fff';
        ctx.fillRect(d.x + w - 8, y + 1, 3, 3);
        ctx.fillStyle = isNight ? '#e8ecf5' : '#2e2e2e';
      }

      // legs animation
      const phase = Math.floor(state.t / 6) % 2;
      if (d.onGround && !duck) {
        ctx.fillRect(d.x + 14, d.y - (phase ? 5 : 2), 7, 10);
        ctx.fillRect(d.x + 28, d.y - (phase ? 2 : 5), 7, 10);
      } else if (duck) {
        ctx.fillRect(d.x + 16, d.y - 3, 8, 5);
        ctx.fillRect(d.x + 34, d.y - 3, 8, 5);
      }
    }

    function drawObstacle(o, isNight = false) {
      if (o.type === 'cactus') {
        ctx.fillStyle = isNight ? '#8de7a6' : '#217a3c';
        ctx.fillRect(o.x, o.y - o.h, o.w, o.h);
        ctx.fillRect(o.x + 4, o.y - o.h - 8, 6, 14);
      } else {
        ctx.fillStyle = isNight ? '#d8dbe3' : '#555';
        ctx.fillRect(o.x, o.y - o.h, o.w, o.h - 8);
        const wingUp = Math.sin(o.flap) > 0;
        if (wingUp) {
          ctx.fillRect(o.x + 8, o.y - o.h - 8, 12, 8);
          ctx.fillRect(o.x + 24, o.y - o.h - 8, 12, 8);
        } else {
          ctx.fillRect(o.x + 8, o.y - 16, 12, 8);
          ctx.fillRect(o.x + 24, o.y - 16, 12, 8);
        }
      }
    }

    function drawCloud(cl, isNight = false) {
      ctx.fillStyle = isNight ? '#3b4252' : '#e8edf6';
      ctx.fillRect(cl.x, cl.y, cl.w, 14);
      ctx.fillRect(cl.x + 8, cl.y - 8, cl.w*0.45, 10);
      ctx.fillRect(cl.x + cl.w*0.45, cl.y - 6, cl.w*0.4, 10);
    }

    function render() {
      ctx.clearRect(0,0,c.width,c.height);

      const scoreInt = Math.floor(state.score);
      const cycle = 500; // switch every 500 points like classic vibe
      const isNight = Math.floor(scoreInt / cycle) % 2 === 1;

      // sky/ground day-night cycle
      ctx.fillStyle = isNight ? '#1f2430' : '#ffffff';
      ctx.fillRect(0,0,c.width,c.height);

      // stars/moon at night
      if (isNight) {
        ctx.fillStyle = '#f4f7ff';
        ctx.beginPath();
        ctx.arc(c.width - 90, 48, 14, 0, Math.PI * 2);
        ctx.fill();
        for (let i = 0; i < 24; i++) {
          const sx = (i * 97 + 43) % c.width;
          const sy = 16 + ((i * 53) % 90);
          ctx.fillRect(sx, sy, 2, 2);
        }
      }

      for (const cl of state.clouds) drawCloud(cl, isNight);

      ctx.strokeStyle = isNight ? '#6b7280' : '#d8d8d8';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y + 1);
      ctx.lineTo(c.width, GROUND_Y + 1);
      ctx.stroke();

      // ground marks
      ctx.fillStyle = isNight ? '#7b8190' : '#d0d0d0';
      for (let i=0;i<12;i++) {
        const x = (i*110 - (state.t*state.speed*0.5)%110);
        ctx.fillRect(x, GROUND_Y + 5, 36, 2);
      }

      for (const o of state.obstacles) drawObstacle(o, isNight);
      drawDino(isNight);

      if (!state.running) {
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fillRect(0,0,c.width,c.height);
        ctx.fillStyle = '#222';
        ctx.font = 'bold 36px Inter, Arial';
        ctx.fillText('GAME OVER', c.width/2 - 120, c.height/2 - 10);
        ctx.font = '18px Inter, Arial';
        ctx.fillText('Press R to restart', c.width/2 - 72, c.height/2 + 24);
      }
    }

    function loop() {
      update();
      render();
      requestAnimationFrame(loop);
    }

    addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        if (!state.ai) jump();
      }
      if (e.code === 'ArrowDown') {
        state.downPressed = true;
        if (!state.ai) setDuck(true);
      }
      if (e.code === 'KeyA') state.ai = !state.ai;
      if (e.code === 'KeyR') reset();
    });
    addEventListener('keyup', (e) => {
      if (e.code === 'ArrowDown') {
        state.downPressed = false;
        if (!state.ai) setDuck(false);
      }
    });

    // Optional: auto-start when offline like Chrome dino spirit
    addEventListener('offline', () => { reset(); state.ai = true; });

    reset();
    loop();
  </script>
</body>
</html>
