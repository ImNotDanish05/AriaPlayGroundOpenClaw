<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chrome Dino AI (Autoplay)</title>
  <style>
    :root { --w: 960; --h: 260; }
    body { margin: 0; background: #f6f7fb; font-family: Inter, system-ui, Arial, sans-serif; display: grid; place-items: center; min-height: 100vh; }
    .wrap { width: min(96vw, calc(var(--w) * 1px)); }
    .hud { display:flex; justify-content:space-between; margin-bottom:8px; color:#333; font-weight:600; }
    canvas { width: 100%; height: auto; border: 2px solid #ddd; background: #fff; image-rendering: pixelated; }
    .tips { margin-top: 8px; color:#666; font-size: 13px; }
    kbd { background:#eee; border:1px solid #d0d0d0; border-bottom-width:2px; border-radius:4px; padding:1px 6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud"><span>ðŸ¦– Dino AI Autoplay</span><span id="score">Score: 0</span></div>
    <canvas id="game" width="960" height="260"></canvas>
    <div class="tips">Manual: <kbd>Space</kbd> jump, <kbd>ArrowDown</kbd> duck. Toggle AI: <kbd>A</kbd>. Restart: <kbd>R</kbd>.</div>
  </div>

  <script>
    const c = document.getElementById('game');
    const ctx = c.getContext('2d');
    const scoreEl = document.getElementById('score');

    const GROUND_Y = 210;
    const gravity = 0.9;
    const jumpVel = -15.5;

    const state = {
      running: true,
      ai: true,
      t: 0,
      score: 0,
      speed: 7,
      spawnCooldown: 0,
      obstacles: [],
      clouds: Array.from({length: 5}, (_,i)=>({x: i*220+120, y: 20 + Math.random()*55, w: 46+Math.random()*24, s: 0.3+Math.random()*0.4})),
      dino: {
        x: 90,
        y: GROUND_Y,
        w: 44,
        h: 48,
        vy: 0,
        ducking: false,
        onGround: true,
        jumpCount: 0,
      },
      downPressed: false,
    };

    function reset() {
      state.running = true;
      state.t = 0;
      state.score = 0;
      state.speed = 7;
      state.spawnCooldown = 30;
      state.obstacles.length = 0;
      Object.assign(state.dino, { y: GROUND_Y, vy: 0, ducking:false, onGround:true, jumpCount:0 });
    }

    function spawnObstacle() {
      const r = Math.random();
      // 0..0.6 cactus, 0.6..1 ptero
      if (r < 0.62) {
        const variant = Math.random();
        const w = variant < 0.4 ? 24 : (variant < 0.8 ? 34 : 46);
        const h = variant < 0.4 ? 40 : (variant < 0.8 ? 52 : 56);
        state.obstacles.push({ type: 'cactus', x: c.width + 20, y: GROUND_Y, w, h });
      } else {
        const lvl = Math.random();
        const flight = lvl < 0.33 ? GROUND_Y - 20 : (lvl < 0.66 ? GROUND_Y - 48 : GROUND_Y - 78);
        state.obstacles.push({ type: 'ptero', x: c.width + 20, y: flight, w: 46, h: 30, flap: 0 });
      }
      const base = Math.max(36, 92 - state.speed * 4.2);
      state.spawnCooldown = base + Math.random() * (base * 0.9);
    }

    function jump() {
      const d = state.dino;
      if (d.onGround) {
        d.vy = jumpVel;
        d.onGround = false;
        d.jumpCount++;
      }
    }

    function setDuck(v) {
      state.dino.ducking = v && !state.dino.onGround ? false : v;
    }

    function updateDino() {
      const d = state.dino;
      d.vy += gravity;
      d.y += d.vy;
      if (d.y >= GROUND_Y) {
        d.y = GROUND_Y;
        d.vy = 0;
        d.onGround = true;
      } else d.onGround = false;
    }

    function dinoBox() {
      const d = state.dino;
      const h = d.ducking && d.onGround ? 30 : d.h;
      const y = d.y - h;
      const w = d.ducking && d.onGround ? 56 : d.w;
      return { x: d.x + 4, y: y + 3, w: w - 8, h: h - 6 };
    }

    function collide(a,b) {
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function simulateRisk(action) {
      const d = state.dino;
      const sim = {
        x: d.x,
        y: d.y,
        vy: d.vy,
        onGround: d.onGround,
        ducking: action === 'duck' && d.onGround,
      };

      if (action === 'jump' && sim.onGround) {
        sim.vy = jumpVel;
        sim.onGround = false;
        sim.ducking = false;
      }

      // clone near obstacles only (performance)
      const obs = state.obstacles
        .filter(o => o.x + o.w > d.x - 20 && o.x < d.x + 520)
        .slice(0, 4)
        .map(o => ({ ...o }));

      const horizon = Math.max(55, Math.floor(92 - state.speed * 1.5));
      let risk = 0;

      for (let i = 0; i < horizon; i++) {
        // physics
        sim.vy += gravity;
        sim.y += sim.vy;
        if (sim.y >= GROUND_Y) {
          sim.y = GROUND_Y;
          sim.vy = 0;
          sim.onGround = true;
        } else {
          sim.onGround = false;
        }

        // if not explicitly duck action, auto release duck after frame 0
        if (i > 0 && action !== 'duck') sim.ducking = false;
        if (!sim.onGround) sim.ducking = false;

        const h = sim.ducking && sim.onGround ? 30 : 48;
        const w = sim.ducking && sim.onGround ? 56 : 44;
        const dBox = { x: sim.x + 4, y: sim.y - h + 3, w: w - 8, h: h - 6 };

        for (const o of obs) {
          o.x -= state.speed;
          const hit = { x: o.x + 3, y: o.y - o.h + 2, w: o.w - 6, h: o.h - 4 };
          const overlap = dBox.x < hit.x + hit.w && dBox.x + dBox.w > hit.x && dBox.y < hit.y + hit.h && dBox.y + dBox.h > hit.y;
          if (overlap) {
            // heavy penalty for predicted collision; sooner collision = worse
            risk += 10000 - i * 80;
          }

          // soft penalty: being too close to obstacle front while descending
          const dx = hit.x - (dBox.x + dBox.w);
          if (dx > -10 && dx < 18 && sim.vy > 0) risk += 12;
        }
      }

      // discourage useless jumps/ducks when safe
      if (action === 'jump' && risk < 5000) risk += 28;
      if (action === 'duck' && risk < 5000) risk += 12;
      return risk;
    }

    function aiControl() {
      if (!state.ai || !state.running) return;
      const d = state.dino;

      // jump cooldown to avoid spam-bounce
      if (state.aiJumpLock == null) state.aiJumpLock = 0;
      if (state.aiJumpLock > 0) state.aiJumpLock--;

      const nearest = state.obstacles
        .filter(o => o.x + o.w > d.x - 8)
        .sort((a,b)=>a.x-b.x)[0];

      if (!nearest) {
        setDuck(false);
        state.jumpPlan = null;
        return;
      }

      const dx = nearest.x - d.x;
      if (dx > 280) {
        setDuck(false);
        return;
      }

      // --- Early jump calibrator with 50% hold rule ---
      // If a jump is detected at distance D, hold decision until obstacle reaches ~50% of D.
      if (!state.jumpPlan) state.jumpPlan = null;

      const apexFrame = Math.abs(jumpVel) / gravity; // ~17 frames
      const dinoCenterX = d.x + d.w * 0.5;
      const obsCenterX = nearest.x + nearest.w * 0.5;
      const tToCenter = (obsCenterX - dinoCenterX) / state.speed;
      const isLowBird = nearest.type === 'ptero' && (nearest.y - nearest.h) > (GROUND_Y - 42);
      const canPlanJump = d.onGround && state.aiJumpLock === 0 && (nearest.type === 'cactus' || isLowBird);

      // create/update plan
      if (canPlanJump && !state.jumpPlan && tToCenter <= (apexFrame + 12) && tToCenter >= 4) {
        const initialDx = Math.max(1, nearest.x - d.x);
        state.jumpPlan = {
          targetType: nearest.type,
          initialDx,
          triggerDx: initialDx * 0.5, // 50% distance rule from Senpai
          createdAt: state.t,
        };
      }

      // execute or expire plan
      if (state.jumpPlan) {
        const curDx = nearest.x - d.x;
        const stale = state.t - state.jumpPlan.createdAt > 120 || curDx < -20;
        const mismatch = state.jumpPlan.targetType !== nearest.type;

        if (stale || mismatch) {
          state.jumpPlan = null;
        } else if (d.onGround && state.aiJumpLock === 0 && curDx <= state.jumpPlan.triggerDx) {
          setDuck(false);
          jump();
          state.aiJumpLock = Math.max(8, Math.floor(15 - state.speed * 0.2));
          state.jumpPlan = null;
          return;
        }
      }

      const riskNone = simulateRisk('none');
      const riskDuck = d.onGround ? simulateRisk('duck') : Infinity;
      const riskJump = (d.onGround && state.aiJumpLock === 0) ? simulateRisk('jump') : Infinity;

      const best = Math.min(riskNone, riskDuck, riskJump);

      if (best === riskJump && riskJump + 100 < riskNone) {
        setDuck(false);
        jump();
        state.aiJumpLock = Math.max(8, Math.floor(15 - state.speed * 0.2));
        return;
      }

      if (best === riskDuck && riskDuck + 40 < riskNone) {
        setDuck(true);
      } else {
        setDuck(false);
      }
    }

    function update() {
      if (!state.running) return;

      state.t++;
      state.score += 0.12;
      state.speed = Math.min(19.5, 7 + state.t / 900);

      state.spawnCooldown -= 1;
      if (state.spawnCooldown <= 0) spawnObstacle();

      for (const cl of state.clouds) {
        cl.x -= cl.s + state.speed * 0.08;
        if (cl.x < -100) {
          cl.x = c.width + Math.random()*120;
          cl.y = 18 + Math.random()*60;
        }
      }

      for (const ob of state.obstacles) {
        ob.x -= state.speed;
        if (ob.type === 'ptero') ob.flap += 0.22;
      }
      state.obstacles = state.obstacles.filter(o => o.x + o.w > -40);

      aiControl();
      updateDino();

      const db = dinoBox();
      for (const o of state.obstacles) {
        const hit = { x: o.x + 3, y: o.y - o.h + 2, w: o.w - 6, h: o.h - 4 };
        if (collide(db, hit)) {
          state.running = false;
          setDuck(false);
          break;
        }
      }

      scoreEl.textContent = `Score: ${Math.floor(state.score)}${state.ai ? ' (AI)' : ''}${state.running ? '' : '  â€” GAME OVER'}`;
    }

    function drawDino() {
      const d = state.dino;
      const duck = d.ducking && d.onGround;
      const h = duck ? 30 : d.h;
      const w = duck ? 56 : d.w;
      const y = d.y - h;

      // body
      ctx.fillStyle = '#2e2e2e';
      ctx.fillRect(d.x + 8, y + 8, w - 10, h - 10);

      // head
      if (!duck) {
        ctx.fillRect(d.x + w - 16, y - 4, 14, 14);
        ctx.fillStyle = '#fff';
        ctx.fillRect(d.x + w - 8, y + 1, 3, 3);
        ctx.fillStyle = '#2e2e2e';
      }

      // legs animation
      const phase = Math.floor(state.t / 6) % 2;
      if (d.onGround && !duck) {
        ctx.fillRect(d.x + 14, d.y - (phase ? 5 : 2), 7, 10);
        ctx.fillRect(d.x + 28, d.y - (phase ? 2 : 5), 7, 10);
      } else if (duck) {
        ctx.fillRect(d.x + 16, d.y - 3, 8, 5);
        ctx.fillRect(d.x + 34, d.y - 3, 8, 5);
      }
    }

    function drawObstacle(o) {
      if (o.type === 'cactus') {
        ctx.fillStyle = '#217a3c';
        ctx.fillRect(o.x, o.y - o.h, o.w, o.h);
        ctx.fillRect(o.x + 4, o.y - o.h - 8, 6, 14);
      } else {
        ctx.fillStyle = '#555';
        ctx.fillRect(o.x, o.y - o.h, o.w, o.h - 8);
        const wingUp = Math.sin(o.flap) > 0;
        if (wingUp) {
          ctx.fillRect(o.x + 8, o.y - o.h - 8, 12, 8);
          ctx.fillRect(o.x + 24, o.y - o.h - 8, 12, 8);
        } else {
          ctx.fillRect(o.x + 8, o.y - 16, 12, 8);
          ctx.fillRect(o.x + 24, o.y - 16, 12, 8);
        }
      }
    }

    function drawCloud(cl) {
      ctx.fillStyle = '#e8edf6';
      ctx.fillRect(cl.x, cl.y, cl.w, 14);
      ctx.fillRect(cl.x + 8, cl.y - 8, cl.w*0.45, 10);
      ctx.fillRect(cl.x + cl.w*0.45, cl.y - 6, cl.w*0.4, 10);
    }

    function render() {
      ctx.clearRect(0,0,c.width,c.height);

      // sky/ground
      ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,c.width,c.height);
      for (const cl of state.clouds) drawCloud(cl);

      ctx.strokeStyle = '#d8d8d8';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y + 1);
      ctx.lineTo(c.width, GROUND_Y + 1);
      ctx.stroke();

      // ground marks
      ctx.fillStyle = '#d0d0d0';
      for (let i=0;i<12;i++) {
        const x = (i*110 - (state.t*state.speed*0.5)%110);
        ctx.fillRect(x, GROUND_Y + 5, 36, 2);
      }

      for (const o of state.obstacles) drawObstacle(o);
      drawDino();

      if (!state.running) {
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fillRect(0,0,c.width,c.height);
        ctx.fillStyle = '#222';
        ctx.font = 'bold 36px Inter, Arial';
        ctx.fillText('GAME OVER', c.width/2 - 120, c.height/2 - 10);
        ctx.font = '18px Inter, Arial';
        ctx.fillText('Press R to restart', c.width/2 - 72, c.height/2 + 24);
      }
    }

    function loop() {
      update();
      render();
      requestAnimationFrame(loop);
    }

    addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        if (!state.ai) jump();
      }
      if (e.code === 'ArrowDown') {
        state.downPressed = true;
        if (!state.ai) setDuck(true);
      }
      if (e.code === 'KeyA') state.ai = !state.ai;
      if (e.code === 'KeyR') reset();
    });
    addEventListener('keyup', (e) => {
      if (e.code === 'ArrowDown') {
        state.downPressed = false;
        if (!state.ai) setDuck(false);
      }
    });

    // Optional: auto-start when offline like Chrome dino spirit
    addEventListener('offline', () => { reset(); state.ai = true; });

    reset();
    loop();
  </script>
</body>
</html>
