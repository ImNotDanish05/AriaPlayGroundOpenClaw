<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chrome Dino AI (Autoplay)</title>
  <style>
    :root { --w: 960; --h: 260; }
    body { margin: 0; background: #f6f7fb; font-family: Inter, system-ui, Arial, sans-serif; display: grid; place-items: center; min-height: 100vh; }
    .wrap { width: min(96vw, calc(var(--w) * 1px)); }
    .hud { display:flex; justify-content:space-between; margin-bottom:8px; color:#333; font-weight:600; }
    canvas { width: 100%; height: auto; border: 2px solid #ddd; background: #fff; image-rendering: pixelated; }
    .tips { margin-top: 8px; color:#666; font-size: 13px; }
    kbd { background:#eee; border:1px solid #d0d0d0; border-bottom-width:2px; border-radius:4px; padding:1px 6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud"><span>ðŸ¦– Dino AI Autoplay</span><span id="score">Score: 0</span></div>
    <canvas id="game" width="960" height="260"></canvas>
    <div class="tips">Manual: <kbd>Space</kbd> jump, <kbd>ArrowDown</kbd> duck. Toggle AI: <kbd>A</kbd>. Restart: <kbd>R</kbd>.</div>
  </div>

  <script>
    const c = document.getElementById('game');
    const ctx = c.getContext('2d');
    const scoreEl = document.getElementById('score');

    const GROUND_Y = 210;
    const gravity = 0.9;
    const jumpVel = -15.5;

    const state = {
      running: true,
      ai: true,
      t: 0,
      score: 0,
      speed: 7,
      spawnCooldown: 0,
      obstacles: [],
      clouds: Array.from({length: 5}, (_,i)=>({x: i*220+120, y: 20 + Math.random()*55, w: 46+Math.random()*24, s: 0.3+Math.random()*0.4})),
      dino: {
        x: 90,
        y: GROUND_Y,
        w: 44,
        h: 48,
        vy: 0,
        ducking: false,
        onGround: true,
        jumpCount: 0,
      },
      downPressed: false,
    };

    function reset() {
      state.running = true;
      state.t = 0;
      state.score = 0;
      state.speed = 7;
      state.spawnCooldown = 30;
      state.obstacles.length = 0;
      Object.assign(state.dino, { y: GROUND_Y, vy: 0, ducking:false, onGround:true, jumpCount:0 });
    }

    function spawnObstacle() {
      const r = Math.random();
      // 0..0.6 cactus, 0.6..1 ptero
      if (r < 0.62) {
        const variant = Math.random();
        const w = variant < 0.4 ? 24 : (variant < 0.8 ? 34 : 46);
        const h = variant < 0.4 ? 40 : (variant < 0.8 ? 52 : 56);
        state.obstacles.push({ type: 'cactus', x: c.width + 20, y: GROUND_Y, w, h });
      } else {
        const lvl = Math.random();
        const flight = lvl < 0.33 ? GROUND_Y - 20 : (lvl < 0.66 ? GROUND_Y - 48 : GROUND_Y - 78);
        state.obstacles.push({ type: 'ptero', x: c.width + 20, y: flight, w: 46, h: 30, flap: 0 });
      }
      const base = Math.max(36, 92 - state.speed * 4.2);
      state.spawnCooldown = base + Math.random() * (base * 0.9);
    }

    function jump() {
      const d = state.dino;
      if (d.onGround) {
        d.vy = jumpVel;
        d.onGround = false;
        d.jumpCount++;
      }
    }

    function setDuck(v) {
      state.dino.ducking = v && !state.dino.onGround ? false : v;
    }

    function updateDino() {
      const d = state.dino;
      d.vy += gravity;
      d.y += d.vy;
      if (d.y >= GROUND_Y) {
        d.y = GROUND_Y;
        d.vy = 0;
        d.onGround = true;
      } else d.onGround = false;
    }

    function dinoBox() {
      const d = state.dino;
      const h = d.ducking && d.onGround ? 30 : d.h;
      const y = d.y - h;
      const w = d.ducking && d.onGround ? 56 : d.w;
      return { x: d.x + 4, y: y + 3, w: w - 8, h: h - 6 };
    }

    function collide(a,b) {
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function obstacleDanger(ob) {
      const d = state.dino;
      const dx = ob.x - d.x;
      const tImpact = dx / state.speed;

      // dynamic reaction window grows with speed
      const react = Math.max(12, 28 - state.speed*1.2);

      if (ob.type === 'cactus') {
        // Jump if cactus is in forward window
        return {
          jump: tImpact > 0 && tImpact < (react + ob.w*0.9),
          duck: false,
          urgency: 1 / Math.max(1, tImpact)
        };
      }

      // Ptero logic:
      // low flight -> jump (if on ground), mid/high -> duck
      const pteroTop = ob.y - ob.h;
      const lowBand = GROUND_Y - 36;
      const shouldJump = pteroTop > lowBand && tImpact > 0 && tImpact < react + 18;
      const shouldDuck = pteroTop <= lowBand && tImpact > 0 && tImpact < react + 22;

      return {
        jump: shouldJump,
        duck: shouldDuck,
        urgency: 1 / Math.max(1, tImpact)
      };
    }

    function aiControl() {
      if (!state.ai || !state.running) return;
      const d = state.dino;

      const ahead = state.obstacles
        .filter(o => o.x + o.w > d.x - 8)
        .sort((a,b)=>a.x-b.x)
        .slice(0,3);

      let needJump = false;
      let needDuck = false;
      let maxUrg = 0;

      for (const o of ahead) {
        const evaln = obstacleDanger(o);
        if (evaln.urgency > maxUrg) maxUrg = evaln.urgency;
        needJump = needJump || evaln.jump;
        needDuck = needDuck || evaln.duck;
      }

      // smarter rule: if already ascending, don't spam jump
      if (needJump && d.onGround) jump();

      // duck primarily for aerial threats and only near impact
      setDuck(needDuck && d.onGround && maxUrg > 0.03);

      // release duck once obstacles passed
      if (!needDuck) setDuck(false);
    }

    function update() {
      if (!state.running) return;

      state.t++;
      state.score += 0.12;
      state.speed = Math.min(19.5, 7 + state.t / 900);

      state.spawnCooldown -= 1;
      if (state.spawnCooldown <= 0) spawnObstacle();

      for (const cl of state.clouds) {
        cl.x -= cl.s + state.speed * 0.08;
        if (cl.x < -100) {
          cl.x = c.width + Math.random()*120;
          cl.y = 18 + Math.random()*60;
        }
      }

      for (const ob of state.obstacles) {
        ob.x -= state.speed;
        if (ob.type === 'ptero') ob.flap += 0.22;
      }
      state.obstacles = state.obstacles.filter(o => o.x + o.w > -40);

      aiControl();
      updateDino();

      const db = dinoBox();
      for (const o of state.obstacles) {
        const hit = { x: o.x + 3, y: o.y - o.h + 2, w: o.w - 6, h: o.h - 4 };
        if (collide(db, hit)) {
          state.running = false;
          setDuck(false);
          break;
        }
      }

      scoreEl.textContent = `Score: ${Math.floor(state.score)}${state.ai ? ' (AI)' : ''}${state.running ? '' : '  â€” GAME OVER'}`;
    }

    function drawDino() {
      const d = state.dino;
      const duck = d.ducking && d.onGround;
      const h = duck ? 30 : d.h;
      const w = duck ? 56 : d.w;
      const y = d.y - h;

      // body
      ctx.fillStyle = '#2e2e2e';
      ctx.fillRect(d.x + 8, y + 8, w - 10, h - 10);

      // head
      if (!duck) {
        ctx.fillRect(d.x + w - 16, y - 4, 14, 14);
        ctx.fillStyle = '#fff';
        ctx.fillRect(d.x + w - 8, y + 1, 3, 3);
        ctx.fillStyle = '#2e2e2e';
      }

      // legs animation
      const phase = Math.floor(state.t / 6) % 2;
      if (d.onGround && !duck) {
        ctx.fillRect(d.x + 14, d.y - (phase ? 5 : 2), 7, 10);
        ctx.fillRect(d.x + 28, d.y - (phase ? 2 : 5), 7, 10);
      } else if (duck) {
        ctx.fillRect(d.x + 16, d.y - 3, 8, 5);
        ctx.fillRect(d.x + 34, d.y - 3, 8, 5);
      }
    }

    function drawObstacle(o) {
      if (o.type === 'cactus') {
        ctx.fillStyle = '#217a3c';
        ctx.fillRect(o.x, o.y - o.h, o.w, o.h);
        ctx.fillRect(o.x + 4, o.y - o.h - 8, 6, 14);
      } else {
        ctx.fillStyle = '#555';
        ctx.fillRect(o.x, o.y - o.h, o.w, o.h - 8);
        const wingUp = Math.sin(o.flap) > 0;
        if (wingUp) {
          ctx.fillRect(o.x + 8, o.y - o.h - 8, 12, 8);
          ctx.fillRect(o.x + 24, o.y - o.h - 8, 12, 8);
        } else {
          ctx.fillRect(o.x + 8, o.y - 16, 12, 8);
          ctx.fillRect(o.x + 24, o.y - 16, 12, 8);
        }
      }
    }

    function drawCloud(cl) {
      ctx.fillStyle = '#e8edf6';
      ctx.fillRect(cl.x, cl.y, cl.w, 14);
      ctx.fillRect(cl.x + 8, cl.y - 8, cl.w*0.45, 10);
      ctx.fillRect(cl.x + cl.w*0.45, cl.y - 6, cl.w*0.4, 10);
    }

    function render() {
      ctx.clearRect(0,0,c.width,c.height);

      // sky/ground
      ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,c.width,c.height);
      for (const cl of state.clouds) drawCloud(cl);

      ctx.strokeStyle = '#d8d8d8';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y + 1);
      ctx.lineTo(c.width, GROUND_Y + 1);
      ctx.stroke();

      // ground marks
      ctx.fillStyle = '#d0d0d0';
      for (let i=0;i<12;i++) {
        const x = (i*110 - (state.t*state.speed*0.5)%110);
        ctx.fillRect(x, GROUND_Y + 5, 36, 2);
      }

      for (const o of state.obstacles) drawObstacle(o);
      drawDino();

      if (!state.running) {
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fillRect(0,0,c.width,c.height);
        ctx.fillStyle = '#222';
        ctx.font = 'bold 36px Inter, Arial';
        ctx.fillText('GAME OVER', c.width/2 - 120, c.height/2 - 10);
        ctx.font = '18px Inter, Arial';
        ctx.fillText('Press R to restart', c.width/2 - 72, c.height/2 + 24);
      }
    }

    function loop() {
      update();
      render();
      requestAnimationFrame(loop);
    }

    addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        if (!state.ai) jump();
      }
      if (e.code === 'ArrowDown') {
        state.downPressed = true;
        if (!state.ai) setDuck(true);
      }
      if (e.code === 'KeyA') state.ai = !state.ai;
      if (e.code === 'KeyR') reset();
    });
    addEventListener('keyup', (e) => {
      if (e.code === 'ArrowDown') {
        state.downPressed = false;
        if (!state.ai) setDuck(false);
      }
    });

    // Optional: auto-start when offline like Chrome dino spirit
    addEventListener('offline', () => { reset(); state.ai = true; });

    reset();
    loop();
  </script>
</body>
</html>
